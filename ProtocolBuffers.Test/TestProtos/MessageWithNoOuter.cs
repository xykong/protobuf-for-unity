// Generated by the protocol buffer compiler.  DO NOT EDIT!

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
using self = global::Google.ProtocolBuffers.TestProtos;

namespace Google.ProtocolBuffers.TestProtos {
  
  public sealed partial class MessageWithNoOuter : pb::GeneratedMessage<MessageWithNoOuter, MessageWithNoOuter.Builder> {
    private static readonly MessageWithNoOuter defaultInstance = new MessageWithNoOuter();
    public static MessageWithNoOuter DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MessageWithNoOuter DefaultInstanceForType {
      get { return defaultInstance; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return self::MultiFileProto.internal__static_protobuf_unittest_MessageWithNoOuter__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable InternalFieldAccessors {
      get { return self::MultiFileProto.internal__static_protobuf_unittest_MessageWithNoOuter__FieldAccessorTable; }
    }
    
    #region Nested types
    public static class Types {
      public enum NestedEnum {
        BAZ = 3,
      }
      
      public sealed partial class NestedMessage : pb::GeneratedMessage<NestedMessage, NestedMessage.Builder> {
        private static readonly NestedMessage defaultInstance = new NestedMessage();
        public static NestedMessage DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override NestedMessage DefaultInstanceForType {
          get { return defaultInstance; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return self::MultiFileProto.internal__static_protobuf_unittest_MessageWithNoOuter_NestedMessage__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable InternalFieldAccessors {
          get { return self::MultiFileProto.internal__static_protobuf_unittest_MessageWithNoOuter_NestedMessage__FieldAccessorTable; }
        }
        
        // optional int32 i = 1;
        private bool hasI;
        private int i_ = 0;
        public bool HasI {
          get { return hasI; }
        }
        public int I {
          get { return i_; }
        }
        
        public static self::MessageWithNoOuter.Types.NestedMessage ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static self::MessageWithNoOuter.Types.NestedMessage ParseFrom(pb::ByteString data,
            pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry))
                   .BuildParsed();
        }
        public static self::MessageWithNoOuter.Types.NestedMessage ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static self::MessageWithNoOuter.Types.NestedMessage ParseFrom(byte[] data,
            pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry))
                   .BuildParsed();
        }
        public static self::MessageWithNoOuter.Types.NestedMessage ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static self::MessageWithNoOuter.Types.NestedMessage ParseFrom(
            global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry))
                   .BuildParsed();
        }
        public static self::MessageWithNoOuter.Types.NestedMessage ParseFrom(pb::CodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static self::MessageWithNoOuter.Types.NestedMessage ParseFrom(pb::CodedInputStream input,
            pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry))
                   .BuildParsed();
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(self::MessageWithNoOuter.Types.NestedMessage prototype) {
          return (Builder) new Builder().MergeFrom(prototype);
        }
        
        public sealed partial class Builder : pb::GeneratedBuilder<self::MessageWithNoOuter.Types.NestedMessage, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          
          // Construct using self::MessageWithNoOuter.Types.NestedMessage.CreateBuilder()
          internal Builder() {}
          
          self::MessageWithNoOuter.Types.NestedMessage result = new self::MessageWithNoOuter.Types.NestedMessage();
          
          protected override self::MessageWithNoOuter.Types.NestedMessage MessageBeingBuilt {
            get { return result; }
          }
          
          public override Builder Clear() {
            result = new self::MessageWithNoOuter.Types.NestedMessage();
            return this;
          }
          
          public override Builder Clone() {
            return new Builder().MergeFrom(result);
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return self::MessageWithNoOuter.Types.NestedMessage.Descriptor; }
          }
          
          public override self::MessageWithNoOuter.Types.NestedMessage DefaultInstanceForType {
            get { return self::MessageWithNoOuter.Types.NestedMessage.DefaultInstance; }
          }
          
          public override self::MessageWithNoOuter.Types.NestedMessage BuildPartial() {
            self::MessageWithNoOuter.Types.NestedMessage returnMe = result;
            result = null;
            return returnMe;
          }
          
          
          // optional int32 i = 1;
          public bool HasI {
            get { return result.HasI; }
          }
          public int I {
            get { return result.I; }
            set { SetI(value); }
          }
          public Builder SetI(int value) {
            result.hasI = true;
            result.i_ = value;
            return this;
          }
          public Builder ClearI() {
            result.hasI = false;
            result.i_ = 0;
            return this;
          }
        }
      }
      
    }
    #endregion
    
    // optional .protobuf_unittest.MessageWithNoOuter.NestedMessage nested = 1;
    private bool hasNested;
    private self::MessageWithNoOuter.Types.NestedMessage nested_ = self::MessageWithNoOuter.Types.NestedMessage.DefaultInstance;
    public bool HasNested {
      get { return hasNested; }
    }
    public self::MessageWithNoOuter.Types.NestedMessage Nested {
      get { return nested_; }
    }
    
    // repeated .protobuf_unittest.TestAllTypes foreign = 2;
    private scg::IList<self::TestAllTypes> foreign_ = pbc::Lists<self::TestAllTypes>.Empty;
    public scg::IList<self::TestAllTypes> ForeignList {
      get { return foreign_; } 
    }
    public int ForeignCount
      { get { return foreign_.Count; }
    }
    public self::TestAllTypes GetForeign(int index) {
      return foreign_ [index];
    }
    
    // optional .protobuf_unittest.MessageWithNoOuter.NestedEnum nested_enum = 3;
    private bool hasNestedEnum;
    private self::MessageWithNoOuter.Types.NestedEnum nestedEnum_ = self::MessageWithNoOuter.Types.NestedEnum.BAZ;
    public bool HasNestedEnum {
      get { return hasNestedEnum; }
    }
    public self::MessageWithNoOuter.Types.NestedEnum NestedEnum {  get { return nestedEnum_; }}
    
    // optional .protobuf_unittest.EnumWithNoOuter foreign_enum = 4;
    private bool hasForeignEnum;
    private self::EnumWithNoOuter foreignEnum_ = self::EnumWithNoOuter.FOO;
    public bool HasForeignEnum {
      get { return hasForeignEnum; }
    }
    public self::EnumWithNoOuter ForeignEnum {  get { return foreignEnum_; }}
    
    public static self::MessageWithNoOuter ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static self::MessageWithNoOuter ParseFrom(pb::ByteString data,
        pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry))
               .BuildParsed();
    }
    public static self::MessageWithNoOuter ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static self::MessageWithNoOuter ParseFrom(byte[] data,
        pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry))
               .BuildParsed();
    }
    public static self::MessageWithNoOuter ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static self::MessageWithNoOuter ParseFrom(
        global::System.IO.Stream input,
        pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry))
               .BuildParsed();
    }
    public static self::MessageWithNoOuter ParseFrom(pb::CodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static self::MessageWithNoOuter ParseFrom(pb::CodedInputStream input,
        pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry))
               .BuildParsed();
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(self::MessageWithNoOuter prototype) {
      return (Builder) new Builder().MergeFrom(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilder<self::MessageWithNoOuter, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      
      // Construct using self::MessageWithNoOuter.CreateBuilder()
      internal Builder() {}
      
      self::MessageWithNoOuter result = new self::MessageWithNoOuter();
      
      protected override self::MessageWithNoOuter MessageBeingBuilt {
        get { return result; }
      }
      
      public override Builder Clear() {
        result = new self::MessageWithNoOuter();
        return this;
      }
      
      public override Builder Clone() {
        return new Builder().MergeFrom(result);
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return self::MessageWithNoOuter.Descriptor; }
      }
      
      public override self::MessageWithNoOuter DefaultInstanceForType {
        get { return self::MessageWithNoOuter.DefaultInstance; }
      }
      
      public override self::MessageWithNoOuter BuildPartial() {
        if (result.foreign_ != pbc::Lists<self::TestAllTypes>.Empty) {
          result.foreign_ = pbc::Lists<self::TestAllTypes>.AsReadOnly(result.foreign_);
        }
        self::MessageWithNoOuter returnMe = result;
        result = null;
        return returnMe;
      }
      
      
      // optional .protobuf_unittest.MessageWithNoOuter.NestedMessage nested = 1;
      public bool HasNested {
        get { return result.HasNested; }
      }
      public self::MessageWithNoOuter.Types.NestedMessage Nested {
        get { return result.Nested; }
        set { SetNested(value); }
      }
      public Builder SetNested(self::MessageWithNoOuter.Types.NestedMessage value) {
        result.hasNested = true;
        result.nested_ = value;
        return this;
      }
      public Builder SetNested(self::MessageWithNoOuter.Types.NestedMessage.Builder builderForValue) {
        result.hasNested = true;
        result.nested_ = builderForValue.Build();
        return this;
      }
      public Builder MergeNested(self::MessageWithNoOuter.Types.NestedMessage value) {
        if (result.HasNested &&
            result.nested_ != self::MessageWithNoOuter.Types.NestedMessage.DefaultInstance) {
          result.nested_ =
            self::MessageWithNoOuter.Types.NestedMessage.CreateBuilder(result.nested_).MergeFrom(value).BuildPartial();
        } else {
          result.nested_ = value;
        }
        result.hasNested = true;
        return this;
      }
      public Builder ClearNested() {
        result.hasNested = false;
        result.nested_ = self::MessageWithNoOuter.Types.NestedMessage.DefaultInstance;
        return this;
      }
      
      // repeated .protobuf_unittest.TestAllTypes foreign = 2;
      public scg::IList<self::TestAllTypes> ForeignList {
        get { return pbc::Lists.AsReadOnly(result.foreign_); }
      }
      public int ForeignCount {
        get { return result.ForeignCount; }
      }
      public self::TestAllTypes GetForeign(int index) {
        return result.GetForeign(index);
      }
      public Builder SetForeign(int index, self::TestAllTypes value) {
        result.foreign_[index] = value;
        return this;
      }
      public Builder SetForeign(int index, self::TestAllTypes.Builder builderForValue) {
        result.foreign_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddForeign(self::TestAllTypes value) {
        if (result.foreign_ == pbc::Lists<self::TestAllTypes>.Empty) {
          result.foreign_ = new scg::List<self::TestAllTypes>();
        }
        result.foreign_.Add(value);
        return this;
      }
      public Builder AddForeign(self::TestAllTypes.Builder builderForValue) {
        if (result.foreign_ == pbc::Lists<self::TestAllTypes>.Empty) {
          result.foreign_ = new scg::List<self::TestAllTypes>();
        }
        result.foreign_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeForeign(scg::IEnumerable<self::TestAllTypes> values) {
        if (result.foreign_ == pbc::Lists<self::TestAllTypes>.Empty) {
          result.foreign_ = new scg::List<self::TestAllTypes>();
        }
        base.AddRange(values, result.foreign_);
        return this;
      }
      public Builder ClearForeign() {
        result.foreign_ = pbc::Lists<self::TestAllTypes>.Empty;
        return this;
      }
      
      // optional .protobuf_unittest.MessageWithNoOuter.NestedEnum nested_enum = 3;
      public bool HasNestedEnum {
        get { return result.HasNestedEnum; }
      }
      public self::MessageWithNoOuter.Types.NestedEnum NestedEnum {
        get { return result.NestedEnum; }
        set { SetNestedEnum(value); }
      }
      public Builder SetNestedEnum(self::MessageWithNoOuter.Types.NestedEnum value) {
        result.hasNestedEnum = true;
        result.nestedEnum_ = value;
        return this;
      }
      public Builder ClearNestedEnum() {
        result.hasNestedEnum = false;
        result.nestedEnum_ = self::MessageWithNoOuter.Types.NestedEnum.BAZ;
        return this;
      }
      
      // optional .protobuf_unittest.EnumWithNoOuter foreign_enum = 4;
      public bool HasForeignEnum {
        get { return result.HasForeignEnum; }
      }
      public self::EnumWithNoOuter ForeignEnum {
        get { return result.ForeignEnum; }
        set { SetForeignEnum(value); }
      }
      public Builder SetForeignEnum(self::EnumWithNoOuter value) {
        result.hasForeignEnum = true;
        result.foreignEnum_ = value;
        return this;
      }
      public Builder ClearForeignEnum() {
        result.hasForeignEnum = false;
        result.foreignEnum_ = self::EnumWithNoOuter.FOO;
        return this;
      }
    }
  }
  
}
